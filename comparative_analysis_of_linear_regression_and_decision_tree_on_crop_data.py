# -*- coding: utf-8 -*-
"""Comparative Analysis of Linear Regression and Decision tree on Crop Data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AKJMGEXLq8gOJsqNr9y3yM2gMWMqClsS

# Import Libraries
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.preprocessing import OneHotEncoder
from sklearn.model_selection import train_test_split, cross_val_score

"""# Import Data

"""

from google.colab import files
uploaded = files.upload()

# import csv file
df = pd.read_csv('crop_production.csv', encoding= 'unicode_escape')

"""# Data Cleaning and Preprocessing"""

df.shape

df.head()

df.info()

#check for null values, gives sum of null values in each column
pd.isnull(df).sum()

# drop null values, inplace for permanent changes
df.dropna(inplace=True)

df.shape

pd.isnull(df).sum() #rechecking nulls

df['Area'] = df['Area'].astype('int')

df['Production'] = df['Production'].astype('int')

df.columns #List of all columns

"""# Exploratory Data Analysis (EDA)"""

# describe() method returns description of the data in the DataFrame (i.e. count, mean, std, etc)
print(df.describe())

sns.heatmap(df[['Crop_Year', 'Area', 'Production']].corr(), annot=True, cmap='coolwarm')
plt.title('Correlation Matrix')
plt.show()

df.groupby('Crop_Year')['Production'].mean().plot(kind='line', title='Average Production over Years')
plt.xlabel('Year')
plt.ylabel('Average Production')
plt.show()

"""# Feature Engineering"""

X = df[['Area', 'Crop_Year']]
y = df['Production']

categorical_features = ['State_Name', 'District_Name', 'Season', 'Crop']
df_encoded = pd.get_dummies(df, columns=categorical_features, drop_first=True)

X = df_encoded.drop(columns=['Production'])
y = df['Production']

"""# Model Training: Linear Regression"""

# Model Training and Evaluation: Linear Regression
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
# Ensure X_test has the same columns as X_train
X_test = X_test.reindex(columns=X_train.columns, fill_value=0)

linear_model = LinearRegression()
linear_model.fit(X_train, y_train)
y_pred_linear = linear_model.predict(X_test)

# Evaluate Linear Regression
mae_linear = mean_absolute_error(y_test, y_pred_linear)
mse_linear = mean_squared_error(y_test, y_pred_linear)
r2_linear = r2_score(y_test, y_pred_linear)

print("Linear Regression Results:")
print(f"Mean Absolute Error (MAE): {mae_linear}")
print(f"Mean Squared Error (MSE): {mse_linear}")
print(f"R-squared (R2): {r2_linear}")

"""# Model Training: Decision Tree Regressor"""

# Model Training and Evaluation: Decision Tree Regressor with Cross-Validation
tree_model = DecisionTreeRegressor(random_state=42, max_depth=10)
tree_model.fit(X_train, y_train)
y_pred_tree = tree_model.predict(X_test)

# Evaluate Decision Tree Regressor
mae_tree = mean_absolute_error(y_test, y_pred_tree)
mse_tree = mean_squared_error(y_test, y_pred_tree)
r2_tree = r2_score(y_test, y_pred_tree)

print("Decision Tree Results:")
print(f"Mean Absolute Error (MAE): {mae_tree}")
print(f"Mean Squared Error (MSE): {mse_tree}")
print(f"R-squared (R2): {r2_tree}")

"""# Cross-validation

"""

# Cross-validation for Decision Tree to confirm performance
tree_cv_scores = cross_val_score(tree_model, X_train, y_train, cv=5)
print(f"Decision Tree Cross-Validation Accuracy: {tree_cv_scores.mean():.3f} (+/- {tree_cv_scores.std() * 2:.3f})")

# Cross-validation for Linear Regression to confirm performance
linear_cv_scores = cross_val_score(linear_model, X_train, y_train, cv=5)
print(f"Linear Regression Cross-Validation Accuracy: {linear_cv_scores.mean():.3f} (+/- {linear_cv_scores.std() * 2:.3f})")

"""# Model Evaluation and Comparison"""

# Model Evaluation and Comparison
comparison_df = pd.DataFrame({
    "Metric": ["Mean Absolute Error (MAE)", "Mean Squared Error (MSE)", "R-squared (R2)"],
    "Linear Regression": [mae_linear, mse_linear, r2_linear],
    "Decision Tree": [mae_tree, mse_tree, r2_tree]
})

print("\nComparative Analysis of Linear Regression and Decision Tree:")
print(comparison_df)

# Calculate the best values for each metric
best_mae = min(mae_linear, mae_tree)
best_mse = min(mse_linear, mse_tree)
best_r2 = max(r2_linear, r2_tree)

# Calculate percentage improvement relative to the best performing model for each metric
comparison_df['Linear Regression (%)'] = [
    (best_mae / mae_linear) * 100 if mae_linear != 0 else 0,
    (best_mse / mse_linear) * 100 if mse_linear != 0 else 0,
    (r2_linear / best_r2) * 100 if best_r2 != 0 else 0
]

comparison_df['Decision Tree (%)'] = [
    (best_mae / mae_tree) * 100 if mae_tree != 0 else 0,
    (best_mse / mse_tree) * 100 if mse_tree != 0 else 0,
    (r2_tree / best_r2) * 100 if best_r2 != 0 else 0
]

# Display the updated comparison table
print("\nComparative Analysis with Percentage Scores:")
print(comparison_df)

"""# Predicting Production for New Inputs"""

# Predicting Production for New Inputs
def predict_production():
    state_name = input("Enter State Name: ")
    district_name = input("Enter District Name: ")
    crop = input("Enter Crop: ")
    area = float(input("Enter Area (in hectares): "))
    crop_year = int(input("Enter Crop Year: "))
    season = input("Enter Season: ")

    input_data = pd.DataFrame({
        'State_Name': [state_name],
        'District_Name': [district_name],
        'Crop': [crop],
        'Area': [area],
        'Crop_Year': [crop_year],
        'Season': [season]
    })

    input_data_encoded = pd.get_dummies(input_data, columns=['State_Name', 'District_Name', 'Crop', 'Season'], drop_first=True)
    input_data_encoded = input_data_encoded.reindex(columns=X_train.columns, fill_value=0)

    linear_pred = linear_model.predict(input_data_encoded)[0]
    tree_pred = tree_model.predict(input_data_encoded)[0]

    print(f"\nPredicted Production using Linear Regression: {linear_pred}")
    print(f"Predicted Production using Decision Tree: {tree_pred}")

# Test the prediction function
predict_production()

import pandas as pd

# Example list
input_list = [
    {'State_Name': 'Bihar', 'District_Name': 'Vaishali', 'Crop': 'Maize', 'Area': 100, 'Crop_Year': 2023, 'Season': 'Kharif'},
    {'State_Name': 'Uttar Pradesh', 'District_Name': 'Kanpur', 'Crop': 'Wheat', 'Area': 150, 'Crop_Year': 2024, 'Season': 'Rabi'},
    {'State_Name': 'Punjab', 'District_Name': 'Ludhiana', 'Crop': 'Rice', 'Area': 200, 'Crop_Year': 2025, 'Season': 'Kharif'},
    # Add more rows as needed
]

# Convert the list of dictionaries to a DataFrame
input_data = pd.DataFrame(input_list)

# One-hot encode the categorical features
input_data_encoded = pd.get_dummies(input_data, columns=['State_Name', 'District_Name', 'Crop', 'Season'], drop_first=True)

# Ensure input_data_encoded has the same columns as the training data
input_data_encoded = input_data_encoded.reindex(columns=X_train.columns, fill_value=0)

# Make predictions with both models
linear_preds = linear_model.predict(input_data_encoded)
tree_preds = tree_model.predict(input_data_encoded)

# Add predictions to the DataFrame
input_data['Predicted Production (Linear Regression)'] = linear_preds
input_data['Predicted Production (Decision Tree)'] = tree_preds

# Display the results
print("Predictions for the input list:")
print(input_data)